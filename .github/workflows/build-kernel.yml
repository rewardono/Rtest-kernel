name: Build GKI Kernel for A135F - NO CCACHE AT ALL
on:
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-22.04
    timeout-minutes: 90
    
    steps:
      # Step 1: Install ONLY what we need (NO ccache)
      - name: Install Dependencies (No ccache)
        run: |
          sudo apt update
          sudo apt install -y \
            build-essential \
            bc \
            bison \
            flex \
            libssl-dev \
            libelf-dev \
            git \
            wget \
            gcc-aarch64-linux-gnu \
            g++-aarch64-linux-gnu
          
          # REMOVE ccache if it exists
          sudo apt remove --purge -y ccache 2>/dev/null || true
          sudo rm -f /usr/bin/ccache /usr/local/bin/ccache /usr/local/bin/cache 2>/dev/null || true
          
          echo "âœ… Dependencies installed (NO ccache)"
      
      # Step 2: Get kernel source and FIX IT COMPLETELY
      - name: Get and Fix Kernel Source
        run: |
          rm -rf kernel
          git clone https://github.com/samsungexynos850/atlas kernel --depth=1
          
          cd kernel
          
          echo "=== NUCLEAR FIX: Removing ALL ccache references ==="
          
          # Create a Python script to find and remove ALL ccache references
          cat > fix_ccache.py << 'EOF'
          import os
          import re
          
          def fix_file(filepath):
              with open(filepath, 'r') as f:
                  content = f.read()
              
              # Remove ALL ccache/cache references
              new_content = re.sub(r'\bccache\b\s*', '', content)
              new_content = re.sub(r'\bcache\b\s*', '', new_content)
              new_content = re.sub(r'\$\(ccache\)', '', new_content)
              new_content = re.sub(r'\$\(cache\)', '', new_content)
              new_content = re.sub(r'"ccache"', '', new_content)
              new_content = re.sub(r'"cache"', '', new_content)
              
              # Remove CCACHE variable definitions
              new_content = re.sub(r'^CCACHE\s*:=.*$', '', new_content, flags=re.MULTILINE)
              new_content = re.sub(r'^export\s+CCACHE.*$', '', new_content, flags=re.MULTILINE)
              
              if new_content != content:
                  with open(filepath, 'w') as f:
                      f.write(new_content)
                  return True
              return False
          
          # Fix all Makefiles, Kbuild files, and shell scripts
          for root, dirs, files in os.walk('.'):
              for file in files:
                  if file.endswith(('Makefile', 'Kbuild', '.mk', '.sh')):
                      filepath = os.path.join(root, file)
                      try:
                          if fix_file(filepath):
                              print(f"Fixed: {filepath}")
                      except:
                          pass
          
          print("=== Checking main Makefile ===")
          with open('Makefile', 'r') as f:
              content = f.read()
              if 'ccache' in content or 'cache' in content:
                  print("WARNING: Still found ccache/cache in Makefile")
                  print(re.findall(r'.*ccache.*|.*cache.*', content))
          
          print("=== Checking scripts/Makefile.host ===")
          if os.path.exists('scripts/Makefile.host'):
              with open('scripts/Makefile.host', 'r') as f:
                  content = f.read()
                  if 'ccache' in content or 'cache' in content:
                      print("WARNING: Still found ccache/cache in scripts/Makefile.host")
          EOF
          
          python3 fix_ccache.py
          
          # Also fix the specific file that's causing the error
          if [ -f "scripts/Makefile.host" ]; then
              echo "=== Manually patching scripts/Makefile.host ==="
              sed -i 's/ccache //g' scripts/Makefile.host
              sed -i 's/cache //g' scripts/Makefile.host
              sed -i 's/$(ccache)//g' scripts/Makefile.host
              sed -i 's/$(cache)//g' scripts/Makefile.host
          fi
          
          # Fix the unused variable
          sed -i '49s/const char \*sys_state\[SYSTEM_END\] = {/const char __maybe_unused \*sys_state\[SYSTEM_END\] = {/' kernel/power/process.c
          
          # Fix malformed compiler flags
          find . -type f \( -name "Makefile*" -o -name "Kbuild*" \) \
            -exec sed -i 's/-implicit-function-declaration/-Wimplicit-function-declaration/g' {} \; 2>/dev/null || true
          
          echo "âœ… Kernel source fixed COMPLETELY"
      
      # Step 3: Add KernelSU
      - name: Add KernelSU
        run: |
          cd kernel
          rm -rf drivers/kernelsu
          git clone https://github.com/tiann/KernelSU --depth=1 ksu_tmp
          mv ksu_tmp/kernel drivers/kernelsu
          
          # Add to build system
          echo 'source "drivers/kernelsu/Kconfig"' >> drivers/Kconfig
          echo 'obj-y += kernelsu/' >> drivers/Makefile
          
          rm -rf ksu_tmp
          echo "âœ… KernelSU added"
      
      # Step 4: Build with EXPLICIT COMPILER SETTINGS
      - name: Build Kernel (Direct Method)
        run: |
          cd kernel
          
          # Clean everything
          make distclean 2>/dev/null || true
          rm -f .config .config.old
          
          # Set environment - EXPLICITLY set compilers
          export ARCH=arm64
          export CROSS_COMPILE=aarch64-linux-gnu-
          
          # CRITICAL: Set HOST compiler explicitly
          export HOSTCC=gcc
          export HOSTCXX=g++
          export HOSTCFLAGS="-O2"
          export HOSTCXXFLAGS="-O2"
          
          # Force disable ccache
          unset CCACHE
          unset CCACHE_DIR
          unset USE_CCACHE
          export CCACHE_DISABLE=1
          
          echo "Configuring kernel..."
          
          # Use gki_defconfig
          make gki_defconfig
          
          # Run olddefconfig to accept all defaults
          make olddefconfig
          
          # Enable KSU
          sed -i 's/# CONFIG_KSU is not set/CONFIG_KSU=y/' .config
          sed -i 's/# CONFIG_MODULES is not set/CONFIG_MODULES=y/' .config
          
          # Run olddefconfig again
          make olddefconfig
          
          echo "Starting build..."
          echo "This will take 10-15 minutes..."
          
          # First, test if host tools build works
          echo "=== Testing host tools build ==="
          make scripts_basic 2>&1 | tee host_build.log
          
          if [ $? -eq 0 ]; then
            echo "âœ… Host tools built successfully!"
            
            # Now build the full kernel
            make -j$(nproc) 2>&1 | tee full_build.log
            
            if [ -f "arch/arm64/boot/Image" ]; then
              echo "ðŸŽ‰ KERNEL BUILD SUCCESSFUL!"
              echo "Size: $(du -h arch/arm64/boot/Image | cut -f1)"
            else
              echo "âŒ Full build failed"
              tail -100 full_build.log
              exit 1
            fi
          else
            echo "âŒ Host tools build failed"
            
            # Try a different approach - build without any host tools
            echo "Trying alternative build method..."
            
            # Manually create fixdep if needed
            echo "=== Manual fixdep build ==="
            cd scripts/basic
            gcc -o fixdep fixdep.c 2>&1 || echo "Manual fixdep build attempt"
            cd ../..
            
            # Try building again
            make -j1 2>&1 | tail -100
            exit 1
          fi
      
      # Step 5: Create flashable package
      - name: Create Flashable Package
        run: |
          cd kernel
          
          if [ ! -f "arch/arm64/boot/Image" ]; then
            echo "âŒ No kernel Image found"
            exit 1
          fi
          
          echo "Creating flashable package..."
          
          # Simple zip structure
          mkdir -p anykernel
          cp arch/arm64/boot/Image anykernel/
          
          cat > anykernel/install.sh << 'EOF'
          #!/system/bin/sh
          # Simple install script
          
          ui_print " "
          ui_print "********************************"
          ui_print "* GKI Kernel for Samsung A135F *"
          ui_print "*     With KernelSU Support    *"
          ui_print "********************************"
          ui_print " "
          
          # Check device
          case $(getprop ro.product.device) in
            a13|a135f|a13x)
              ui_print "Device detected: $(getprop ro.product.device)"
              ;;
            *)
              ui_print "Warning: Unknown device"
              ;;
          esac
          
          # Backup
          ui_print "- Backing up current kernel..."
          dd if=/dev/block/by-name/boot of=/sdcard/boot_backup.img 2>/dev/null || true
          
          # Flash
          ui_print "- Flashing new kernel..."
          dd if=$INSTALLER/Image of=/dev/block/by-name/boot 2>/dev/null || true
          
          ui_print "- Done!"
          ui_print " "
          EOF
          
          chmod +x anykernel/install.sh
          
          # Create zip
          cd anykernel
          zip -r9 ../A135F-Kernel.zip *
          
          echo "âœ… Flashable zip created"
          ls -lh ../A135F-Kernel.zip
      
      # Step 6: Upload artifacts
      - name: Upload Kernel
        uses: actions/upload-artifact@v4
        with:
          name: A135F-Kernel-COMPLETE
          path: |
            kernel/arch/arm64/boot/Image
            kernel/A135F-Kernel.zip
          retention-days: 7
